diff -up Linux-PAM-1.1.1/modules/pam_pwhistory/opasswd.c.pwhfixes Linux-PAM-1.1.1/modules/pam_pwhistory/opasswd.c
--- Linux-PAM-1.1.1/modules/pam_pwhistory/opasswd.c.pwhfixes	2009-06-16 09:35:09.000000000 +0200
+++ Linux-PAM-1.1.1/modules/pam_pwhistory/opasswd.c	2012-10-12 09:32:22.305146580 +0200
@@ -94,6 +94,23 @@ parse_entry (char *line, opwd *data)
   return 0;
 }
 
+static int
+compare_password(const char *newpass, const char *oldpass)
+{
+  char *outval;
+#ifdef HAVE_CRYPT_R
+  struct crypt_data output;
+
+  output.initialized = 0;
+
+  outval = crypt_r (newpass, oldpass, &output);
+#else
+  outval = crypt (newpass, oldpass);
+#endif
+
+  return strcmp(outval, oldpass) == 0;
+}
+
 /* Check, if the new password is already in the opasswd file.  */
 int
 check_old_password (pam_handle_t *pamh, const char *user,
@@ -164,23 +181,18 @@ check_old_password (pam_handle_t *pamh,
 
   fclose (oldpf);
 
-  if (found)
+  if (found && entry.old_passwords)
     {
       const char delimiters[] = ",";
-      struct crypt_data output;
       char *running;
       char *oldpass;
 
-      memset (&output, 0, sizeof (output));
-
-      running = strdupa (entry.old_passwords);
-      if (running == NULL)
-	return PAM_BUF_ERR;
+      running = entry.old_passwords;
 
       do {
 	oldpass = strsep (&running, delimiters);
 	if (oldpass && strlen (oldpass) > 0 &&
-	    strcmp (crypt_r (newpass, oldpass, &output), oldpass) == 0)
+	    compare_password(newpass, oldpass) )
 	  {
 	    if (debug)
 	      pam_syslog (pamh, LOG_DEBUG, "New password already used");
@@ -297,8 +309,12 @@ save_old_password (pam_handle_t *pamh, c
 	    buflen = DEFAULT_BUFLEN;
 	    buf = malloc (buflen);
 	    if (buf == NULL)
-	      return PAM_BUF_ERR;
-
+              {
+		fclose (oldpf);
+		fclose (newpf);
+		retval = PAM_BUF_ERR;
+		goto error_opasswd;
+              }
 	  }
 	buf[0] = '\0';
 	fgets (buf, buflen - 1, oldpf);
@@ -308,7 +324,12 @@ save_old_password (pam_handle_t *pamh, c
 	cp = buf;
 	save = strdup (buf); /* Copy to write the original data back.  */
 	if (save == NULL)
-	  return PAM_BUF_ERR;
+          {
+	    fclose (oldpf);
+	    fclose (newpf);
+	    retval = PAM_BUF_ERR;
+	    goto error_opasswd;
+          }
 
 	if (n < 1)
 	  break;
@@ -337,31 +358,30 @@ save_old_password (pam_handle_t *pamh, c
 		found = 1;
 
 		/* Don't save the current password twice */
-		if (entry.old_passwords)
+		if (entry.old_passwords && entry.old_passwords[0] != '\0')
 		  {
-		    /* there is only one password */
-		    if (strcmp (entry.old_passwords, oldpass) == 0)
-		      goto write_old_data;
-		    else
-		      {
-			/* check last entry */
-			cp = strstr (entry.old_passwords, oldpass);
+		    char *last = entry.old_passwords;
 
-			if (cp && strcmp (cp, oldpass) == 0)
-			  {  /* the end is the same, check that there
-				is a "," before. */
-			    --cp;
-			    if (*cp == ',')
-			      goto write_old_data;
-			  }
+		    cp = entry.old_passwords;
+		    entry.count = 1;  /* Don't believe the count */
+		    while ((cp = strchr (cp, ',')) != NULL)
+		      {
+			entry.count++;
+			last = ++cp;
 		      }
+
+		    /* compare the last password */
+		    if (strcmp (last, oldpass) == 0)
+		      goto write_old_data;
 		  }
+		else
+		  entry.count = 0;
 
 		/* increase count.  */
 		entry.count++;
 
 		/* check that we don't remember to many passwords.  */
-		while (entry.count > howmany)
+		while (entry.count > howmany && entry.count > 1)
 		  {
 		    char *p = strpbrk (entry.old_passwords, ",");
 		    if (p != NULL)
@@ -369,12 +389,13 @@ save_old_password (pam_handle_t *pamh, c
 		    entry.count--;
 		  }
 
-		if (entry.old_passwords == NULL)
+		if (entry.count == 1)
 		  {
 		    if (asprintf (&out, "%s:%s:%d:%s\n",
 				  entry.user, entry.uid, entry.count,
 				  oldpass) < 0)
 		      {
+		        free (save);
 			retval = PAM_AUTHTOK_ERR;
 			fclose (oldpf);
 			fclose (newpf);
@@ -387,6 +408,7 @@ save_old_password (pam_handle_t *pamh, c
 				  entry.user, entry.uid, entry.count,
 				  entry.old_passwords, oldpass) < 0)
 		      {
+		        free (save);
 			retval = PAM_AUTHTOK_ERR;
 			fclose (oldpf);
 			fclose (newpf);
@@ -479,6 +501,7 @@ save_old_password (pam_handle_t *pamh, c
   rename (opasswd_tmp, OLD_PASSWORDS_FILE);
  error_opasswd:
   unlink (opasswd_tmp);
+  free (buf);
 
   return retval;
 }
diff -up Linux-PAM-1.1.1/modules/pam_pwhistory/pam_pwhistory.c.pwhfixes Linux-PAM-1.1.1/modules/pam_pwhistory/pam_pwhistory.c
--- Linux-PAM-1.1.1/modules/pam_pwhistory/pam_pwhistory.c.pwhfixes	2012-07-19 14:37:25.000000000 +0200
+++ Linux-PAM-1.1.1/modules/pam_pwhistory/pam_pwhistory.c	2012-10-12 09:33:21.060453523 +0200
@@ -155,10 +155,6 @@ pam_sm_chauthtok (pam_handle_t *pamh, in
   if (pwd == NULL)
     return PAM_USER_UNKNOWN;
 
-  /* Ignore root if not enforced */
-  if (pwd->pw_uid == 0 && !options.enforce_for_root)
-    return PAM_SUCCESS;
-
   if ((strcmp(pwd->pw_passwd, "x") == 0)  ||
       ((pwd->pw_passwd[0] == '#') &&
        (pwd->pw_passwd[1] == '#') &&
@@ -211,11 +207,18 @@ pam_sm_chauthtok (pam_handle_t *pamh, in
       if (check_old_password (pamh, user, newpass,
 			      options.debug) != PAM_SUCCESS)
 	{
-	  pam_error (pamh,
-		     _("Password has been already used. Choose another."));
-	  newpass = NULL;
-	  /* Remove password item, else following module will use it */
-          pam_set_item (pamh, PAM_AUTHTOK, (void *) NULL);
+	  if (getuid() || options.enforce_for_root ||
+	      (flags & PAM_CHANGE_EXPIRED_AUTHTOK))
+	    {
+	      pam_error (pamh,
+		         _("Password has been already used. Choose another."));
+	      newpass = NULL;
+	      /* Remove password item, else following module will use it */
+	      pam_set_item (pamh, PAM_AUTHTOK, (void *) NULL);
+	    }
+	  else
+	    pam_info (pamh,
+		       _("Password has been already used."));
 	}
     }
 
